#include "reg52.h"			 //此文件中定义了单片机的一些特殊功能寄存器

typedef unsigned int u16;	  //对数据类型进行声明定义
typedef unsigned char u8;

//--定义使用的IO口--//
sbit IN1 = P0^0;//驱动输出口
sbit IN2 = P0^1;
sbit IN3 = P0^2;
sbit IN4 = P0^3;

sbit Dir = P2^7;//寻迹左
sbit k3 = P2^6;//寻迹中
sbit LR_1 = P2^5;//寻迹右1
sbit LR_2 = P2^4;//寻迹右2

//sbit k3=P3^2;//bit DIR;
sbit PWM=P2^1;

//--定义全局变量--// 
u16 value,timer1,count;	//	count,




/*******************************************************************************
* 函 数 名         : Timer1Init
* 函数功能		   : 定时器1初始化
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Timer1Init()
{
	TMOD|=0X10;//选择为定时器1模式，工作方式1，仅用TR1打开启动。

	TH1 = 0xFF; 
	TL1 = 0xff;   //1us
		
	ET1=1;//打开定时器1中断允许
	TR1=1;//打开定时器			
}





/*******************************************************************************
* 函 数 名         : Timer2Init
* 函数功能		   : 定时器2初始化
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
/*
void Timer2Init()
{
	TMOD|=0X10;//选择为定时器1模式，工作方式1，仅用TR2打开启动。

	TH2 = 0xFF; 
	TL2 = 0xff;   //1us
		
	ET2=1;//打开定时器2中断允许
	TF2=1;//打开定时器
	EXF2=1;			
}
*/




/*******************************************************************************
* 函 数 名         : Int1Init()
* 函数功能		   : 设置外部中断1
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Int0Init()
{
	//设置INT0
	IT0=1;//跳变沿出发方式（下降沿）
	EX0=1;//打开INT0的中断允许。	
	EA=1;//打开总中断	
}




/*******************************************************************************
* 函 数 名         : Delay10ms(c)
* 函数功能		   : 延时函数
* 输    入         : n（10毫秒）
* 输    出         : 无
*******************************************************************************/
void Delay10ms(unsigned int c)   //误差 0us
{
    unsigned char a,b;
    for(;c>0;c--)
        for(b=38;b>0;b--)
            for(a=130;a>0;a--);
}





/*******************************************************************************
* 函 数 名         : pwmcontrol()
* 函数功能		   : 脉宽调节（控制速度）
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void  pwmcontrol(u16 rate)
{
//	if(count>100)							
//		{  				count=0;}
 		value = rate;		
		if(timer1>1000)  	//PWM周期为1000*1us
		{
			timer1=0;
		}

		if(timer1 <value)	
		{
			PWM=1;
		}
		else
		{
			PWM=0;
		}
}




/*******************************************************************************
* 函 数 名         : 方向函数（前进，左拐，右拐，停车）
* 函数功能		   : 转向
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Forward() 				//前进
{ IN1=1;IN2=0;IN3=1;IN4=0;}		 

void TurnLeft_0()			//小左转 
{IN1=0;IN2=0;IN3=1;IN4=0;}

 void TurnLeft_1()			//大左转 
{IN1=0;IN2=1;IN3=1;IN4=0;}

void TurnRight_0()			//小右转 
{IN1=1;IN2=0;IN3=0;IN4=0;}

void TurnRight_1()			//大右转 
{IN1=1;IN2=0;IN3=0;IN4=1;}

void Stop()					//停车
{ IN1=1;IN2=1;IN3=1;IN4=1; }




/*******************************************************************************
* 函 数 名         : pwmcontrol()
* 函数功能		   : 脉宽调节（控制速度）
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Findway()
{		
	if(LR_1==1&&LR_2==0)	{pwmcontrol(100);TurnLeft_0();} //小左拐  
	else if(LR_1==0&&LR_2==1)	{pwmcontrol(100);TurnRight_0();	}//小右拐
	else if(LR_1==0&&LR_2==0)	{pwmcontrol(150);Forward();}	 	 //全亮靠右  
/*	
		   	unsigned char j;
    		for(j=10;j>0;j--)
			{
				Forward();
				pwmcontrol(100);	  
			}
    	    for(j=5;j>0;j--)
			{
				TurnRight();
				pwmcontrol(100);	
			}
	} */
	else if(LR_1==1&&LR_2==1)	{pwmcontrol(150);Forward();} //全黑直行
}





  /*******************************************************************************
* 函 数 名       : DirAdj()
* 函数功能		 : 调整方向
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void DirAdj()
{	
//	unsigned char i;
	Stop();				//停止
	while(k3==0||Dir==0||LR_1==0)					 //检测
	{
		if(Dir==1&&LR_1==0)	{pwmcontrol(100);TurnLeft_1();	}				//进行调整
		else if(Dir==0&&LR_1==1)   {pwmcontrol(100);TurnRight_1();	}
//		else if(Dir==0&&LR_1==0)	{pwmcontrol(60);Forward();	}	   
	}
					
}




 /*******************************************************************************
* 函 数 名       : Turning90
* 函数功能		 : 90度转弯
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void Turning90()
{
	unsigned char i,j;
		for(i=10;i>0;i--)
    	    for(j=60;j>0;j--)
			{
				Forward();
				pwmcontrol(150);	
			}
		for(i=9;i>0;i--)
    		for(j=60;j>0;j--)
			{
				TurnLeft_0();
				pwmcontrol(100);	  
			}
		for(i=20;i>0;i--)
    	    for(j=40;j>0;j--)
			{
				Forward();
				pwmcontrol(150);	
			}
		for(i=5;i>0;i--)
    		for(j=30;j>0;j--)
			{
				TurnLeft_0();
				pwmcontrol(100);	  
			}
		count++;
}






/*******************************************************************************
* 函 数 名       : Overtake()
* 函数功能		 : 后车超车
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void Overtake()
{
	unsigned char i,j;
	Stop();		   //stop并延时
	Delay10ms(10);

	for(i=15;i>0;i--)	//原地左转约90度
		for(j=55;j>0;j--)
		{pwmcontrol(100);TurnLeft_1();}
	Stop();
	Delay10ms(2);

	for(i=30;i>0;i--)	//直走入超车区
		for(j=60;j>0;j--)	   
		{pwmcontrol(150);Forward();}
	Stop();
	Delay10ms(2);

	for(i=12;i>0;i--)	//原地右转约90度
		for(j=50;j>0;j--)		 
		{pwmcontrol(100);TurnRight_1();}
	Stop();
	Delay10ms(2);

	for(i=50;i>0;i--)	//超车
		for(j=60;j>0;j--)	   
		{pwmcontrol(150);Forward();}	   
	Stop();
	Delay10ms(2);

	for(i=12;i>0;i--)	//原地右转约90度
		for(j=50;j>0;j--)		  
		{pwmcontrol(100);TurnRight_1();}
	Stop();
	Delay10ms(2);

	for(i=30;i>0;i--)	//直走出超车区
		for(j=60;j>0;j--)	   
		{pwmcontrol(100);Forward();}
	Stop();
	Delay10ms(2);

	for(i=15;i>0;i--)	//原地左转约90度
		for(j=55;j>0;j--)		
		{pwmcontrol(100);TurnLeft_1();}			
	Stop();	
	Delay10ms(10);			   //超车完成
}




/*******************************************************************************
* 函 数 名       : GetDist()
* 函数功能		 : 判断前车距离
* 输    入       : 无
* 输    出    	 : 有（0/1）
*******************************************************************************/
int GetDist()
{
	//if()   return 1;
	//if()   return 0;
	return 0;
}




/*******************************************************************************
* 函 数 名       : Wait()
* 函数功能		 : 前车等车
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void Wait()
{
	while(1)
	{
		if(k3==1)		  //超声波检测到物体后进入循环
		{	while(1)	
				if(k3==0)	break;  //检测到物体走后跳出循环	  
			break;
		}
	}
	Delay10ms(1);		  //延时1s
}




/*******************************************************************************
* 函 数 名       : main
* 函数功能		 : 主函数
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void main()
{	
	unsigned char i,j;
	Delay10ms(100);
	EA=1;//打开总中断
	Timer1Init();  //定时器1初始化	
//	Int0Init();	  //外部中断0初始化
	while(1)
	{
		pwmcontrol(100);
	//	Overtake();
		Wait();
		Delay10ms(10);
	for(i=50;i>0;i--)	//超车
		for(j=60;j>0;j--)	   
		{pwmcontrol(150);Forward();}	   
	Stop();
	//	Findway();
	//	if(k3==1)
	//		 DirAdj();
	//		 Turning90();

//		Turning90();
//		IN4=~IN4;
//		Forward111();
//		Delay10ms(100);		
	}		
}




/*******************************************************************************
* 函 数 名       : Time1
* 函数功能		 : 定时器1的中断函数
* 输    入       : 无
* 输    出       : 无
*******************************************************************************/
void Time1(void) interrupt 3    //3 为定时器1的中断号  1 定时器0的中断号 0 外部中断1 2 外部中断2  4 串口中断
{
//	if(count%4!=0)
	TH1 = 0xFF; 
	TL1 = 0xff;   //1us
	timer1++; 
 //   count++;
	
}




/*******************************************************************************
* 函 数 名       : Int0()
* 函数功能		 : 外部中断1的中断函数
* 输    入       : 无
* 输    出       : 无
*******************************************************************************/
void Int0()	interrupt 0		//外部中断0的中断函数
{
	Delay10ms(1);	 //延时消抖
	if(k3==1)
	{
		Turning90();
	}
}
