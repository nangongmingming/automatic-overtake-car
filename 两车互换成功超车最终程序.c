/**********************此程序为1车程序**********************/


#include "reg52.h"			 //此文件中定义了单片机的一些特殊功能寄存器
#include<intrins.h>  
typedef unsigned int u16;	  //对数据类型进行声明定义
typedef unsigned char u8;

//--定义使用的IO口--//
sbit IN1 = P0^0;//驱动输出口
sbit IN2 = P0^1;
sbit IN3 = P0^2;
sbit IN4 = P0^3;

sbit Dir = P2^7;//左
sbit k3 = P2^6;//中
sbit LR_1 = P2^5;//寻迹右1
sbit LR_2 = P2^4;//寻迹右2

sbit PWM=P2^1;

sbit trig=P3^1;           //触发控制信号输入  
sbit echo=P3^0;           //回响信号输出 


sbit LED1=P1^2;
sbit LED2=P1^3;			   //测试灯	 D4
sbit LED3=P1^4;			   //R9	,D5
//--定义全局变量--// 
bit  flag =0,logo;				//flag：测距中断溢出标志
u16 value,timer1,time=0,D_timer;	//D_timer:超声波周期 time:超声波时间
u8	count;					//count：黑线条数
unsigned long s=0;			//s：测距距离


/*******************************************************************************
* 函 数 名         : Timer1Init
* 函数功能		   : 定时器1初始化
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Timer1Init()
{
	TMOD|=0X10;//选择为定时器1模式，工作方式1，仅用TR1打开启动。

	if(count!=3)
	{
		TH1 = 0xFF; 
		TL1 = 0xff;   //1us
	}
	else if(count==3)
	{
		TH1 = 65036/256; 
		TL1 = 65036%256;
	}		

	ET1=1;//打开定时器1中断允许
	TR1=1;//打开定时器			
}






/*******************************************************************************
* 函 数 名         : Timer0Init
* 函数功能		   : 定时器0初始化
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Timer0Init()
{
	TMOD|=0X01;//选择为定时器0模式，工作方式1，仅用TR1打开启动。

	TH0 = 0; 
	TL0 = 0;   //1us
		
	ET0=1;//打开定时器0中断允许
	TR0=1;//打开定时器			
}




/*******************************************************************************
* 函 数 名         : Timer2Init
* 函数功能		   : 定时器2初始化
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
/*
void Timer2Init()
{
	TMOD|=0X10;//选择为定时器1模式，工作方式1，仅用TR2打开启动。

	TH2 = 0xFF; 
	TL2 = 0xff;   //1us
		
	ET2=1;//打开定时器2中断允许
	TF2=1;//打开定时器
	EXF2=1;			
}
*/





/*******************************************************************************
* 函 数 名         : Int1Init()
* 函数功能		   : 设置外部中断1
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
/*void Int0Init()
{
	//设置INT0
	IT0=1;//跳变沿出发方式（下降沿）
	EX0=1;//打开INT0的中断允许。	
	EA=1;//打开总中断	
}
 */



/*******************************************************************************
* 函 数 名         : Delay10ms(c)
* 函数功能		   : 延时函数
* 输    入         : n（10毫秒）
* 输    出         : 无
*******************************************************************************/
void Delay10ms(unsigned int c)   //误差 0us
{
    unsigned char a,b;
    for(;c>0;c--)
        for(b=38;b>0;b--)
            for(a=130;a>0;a--);
}





/*******************************************************************************
* 函 数 名         : pwmcontrol()
* 函数功能		   : 脉宽调节（控制速度）
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void  pwmcontrol(u16 rate)
{
 		value = rate;		
		if(timer1>1000)  	//PWM周期为1000*1us
		{
			timer1=0;
		}

		if(timer1 <value)	
		{
			PWM=1;
		}
		else
		{
			PWM=0;
		}
}




/*******************************************************************************
* 函 数 名         : 方向函数（前进，左拐，右拐，停车）
* 函数功能		   : 转向
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Forward() 				//前进
{ IN1=1;IN2=0;IN3=1;IN4=0;}		 

void TurnLeft_0()			//小左转 
{IN1=0;IN2=0;IN3=1;IN4=0;}

void TurnLeft_1()			//大左转 
{IN1=0;IN2=1;IN3=1;IN4=0;}

void TurnRight_0()			//小右转 
{IN1=1;IN2=0;IN3=0;IN4=0;}

void TurnRight_1()			//大右转 
{IN1=1;IN2=0;IN3=0;IN4=1;}

void Stop()					//停车
{ IN1=1;IN2=1;IN3=1;IN4=1; }




/*******************************************************************************
* 函 数 名         : Findway()
* 函数功能		   : 循迹
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Findway()
{		
		 if(LR_1==1&&LR_2==0)	{pwmcontrol(85); TurnLeft_1();} //大左拐  
	else if(LR_1==0&&LR_2==1)	{pwmcontrol(90); TurnRight_0();}//小右拐
	else if(LR_1==0&&LR_2==0)	{pwmcontrol(110); Forward();}	 //全亮直行  
	else if(LR_1==1&&LR_2==1)	{pwmcontrol(110); Forward();} //全黑直行
}





  /*******************************************************************************
* 函 数 名       : DirAdj()
* 函数功能		 : 调整方向
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void DirAdj()
{	
   	   	   if(LR_1==1&&LR_2==0)	{pwmcontrol(100); TurnLeft_1();}     //  大左拐
	else if(LR_1==0&&LR_2==1)	{pwmcontrol(90); TurnRight_0();}    //	 小右拐
	else if(LR_1==0&&LR_2==0)	{pwmcontrol(100); Forward();}	    //   全亮直行
	else if(LR_1==1&&LR_2==1)	{pwmcontrol(100); Forward();}       //	  全黑直行

}




 /*******************************************************************************
* 函 数 名       : Turning90
* 函数功能		 : 90度转弯
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void Turning90()
{
	unsigned char i,j;
	for(i=34;i>0;i--)
    {   
		for(j=34;j>0;j--)
		{
			Forward();
			pwmcontrol(100);	
		}
	 	for(j=6;j>0;j--)
		{
			Findway();
			pwmcontrol(100);	
		}	
	}
	for(i=10;i>0;i--)
    	for(j=37;j>0;j--)
		{
			TurnLeft_1();
			pwmcontrol(95);	  
		}
	count++;
}





/*******************************************************************************
* 函 数 名       : GetDist()
* 函数功能		 : 判断前车距离
* 输    入       : 无
* 输    出    	 : 有（0/1）
*******************************************************************************/
void GetDist()
{//	   	u16 i;

	while(!echo);  //当echo为零时等待    	 
	TR0=1;       //开启计数    
//	LED2=0;
	while(echo);   //当echo为1计数并等待   
	TR0=0;    //关闭计数    
//		LED2=1;LED1=0;					   //-----------D3亮					   

	time=TH0*256+TL0;    
	TH0=0;   
	TL0=0;   
	s=(time*1.7)/100;     //算出来是CM    
}




/*******************************************************************************
* 函 数 名      : OverFindway()
* 函数功能		  : 超车寻迹
* 输    入       : 无
* 输    出    	  : 无
*******************************************************************************/
void OverFindway()
{		
		 if(Dir==1&&k3==0)	{pwmcontrol(90);TurnLeft_0();} //小左拐  			 0白  1黑不亮
	else if(Dir==0&&k3==1)	{pwmcontrol(100);TurnRight_1();	}//大右拐
	else if(Dir==0&&k3==0)	{pwmcontrol(100);Forward();}	//若检测不到线，直行
	else if(Dir==1&&k3==1)	{pwmcontrol(100); Forward();}       //	  全黑直行
}





/*******************************************************************************
* 函 数 名       : Overtake()
* 函数功能		 : 后车超车
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void Overtake()
{	 unsigned char i,j;
	Stop();		   //stop并延时
	Delay10ms(10);

	for(i=8;i>0;i--)	//原地左转约90+度
		for(j=58;j>0;j--)
		{pwmcontrol(150);TurnLeft_1();}
	Stop();
	Delay10ms(5);		  

	for(i=28;i>0;i--)	//直走入超车区
		for(j=60;j>0;j--)	   
		{pwmcontrol(150);Forward();}
	Stop();
	Delay10ms(10);  		  

	for(i=7;i>0;i--)	//原地右转约90度
		for(j=60;j>0;j--)		 
		{pwmcontrol(150);TurnRight_1();}
	Stop();
	Delay10ms(5);	   	 

	for(i=87;i>0;i--)	//超车
		for(j=80;j>0;j--)	   
		{OverFindway();}	   
	Stop();
	Delay10ms(10);		 

	for(i=10;i>0;i--)	//原地右转约90度
		for(j=60;j>0;j--)		  
		{pwmcontrol(150);TurnRight_1();}
	Stop();
	Delay10ms(5);

	for(i=31;i>0;i--)	//直走出超车区
		for(j=60;j>0;j--)	   
		{pwmcontrol(150);Forward();}
	Stop();
	Delay10ms(5);

	for(i=9;i>0;i--)	//原地左转约80度
		for(j=59;j>0;j--)		
		{pwmcontrol(150);TurnLeft_1();}			
	Stop();	
	Delay10ms(5);			    

	for(i=20;i>0;i--)      	//超车结束调整姿势
		for(j=40;j>0;j--)	   
		{DirAdj();}	   
	Stop();
	Delay10ms(10);				   //超车完成
	count++;			//切换回超声波检测
	Timer1Init();	//count=3		//初始化定时器1		
		
	Stop();
 	count++;		//count=4	  //恢复pwm控制
	Timer1Init();
	logo=0;					  //变为1车
}





/*******************************************************************************
* 函 数 名       : Wait()
* 函数功能		 : 前车等车
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void Wait()
{
	u16 i;
	LED1=0;
	
	for(i=0;i<2300;i++)		Findway();		 //直行一段距离  		 
	
	count++;			//切换回超声波检测
	Timer1Init();	//count=3		//初始化定时器1		
		
		Stop();

	LED1=1;
	LED2=1;
	LED3=1;
	while(1)
	{	
		GetDist();
		if(s<20)		  //超声波检测到物体后进入循环
		{	
			LED3=0;		   //R9亮
			while(1)
			{	
				LED2=0;			//R8亮
				GetDist();
				if(s>30) break;  //检测到物体走后跳出循环	  
			}
			break;
		}
	}
	LED3=1;
	LED2=1;
	Delay10ms(100);		  //延时1s
//	LED2=1;
	logo=1;		//换为2车
	count++;	//count=4	  //恢复pwm控制
	Timer1Init();
}




/*******************************************************************************
* 函 数 名       : Decide()
* 函数功能		 : 超等判断
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/

void Decide()
{
	u16 i,j;
	count--;			//count变为2		 //这里count先自减再自加的作用是在使用超声波前再使用一次pwm
	LED2=0;						//第三次转弯后LED1亮	  ------D4亮
	for(i=44;i>0;i--)
	  	for(j=70;j>0;j--)			 //
			Findway();				
	for(i=1500;i>0;i--)
		Stop();
	LED2=1;				   	//向前走后LED1灭	 -----------D4灭
		
	if(logo)  Overtake();	 //测到前方有车时超车  
	else	  Wait();		//无车时作为等待车		
			 
}





/*******************************************************************************
* 函 数 名       : main
* 函数功能		 : 主函数
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void main()
{	
	unsigned char i,j;
	Delay10ms(100);
	EA=1;		//打开总中断
	Timer1Init();  //定时器1初始化	
	Timer0Init();  //定时器0初始化
//	Int0Init();	  //外部中断0初始化
	count=0;	  //黑线条数初始化
	logo =1;	  //1车标志
	while(1)
	{
		LED3=0;			 //--------D5亮
		Findway();			  //循迹
		if(Dir==1)			  //检测到黑线
		{	 
			count=count%5;	  //每圈清零一次
			if(count==2)	  //当为超车转弯线时转弯后进入超等判断
			{
			//	for(i=400;i>0;i--)
	  		//		Forward();
			
				for(i=32;i>0;i--)
   				{   
					for(j=32;j>0;j--)
					{
						Forward();
						pwmcontrol(100);	
					}
	 				for(j=6;j>0;j--)
					{
						Findway();
						pwmcontrol(100);	
					}	
				}
				for(i=10;i>0;i--)
    				for(j=34;j>0;j--)
				{
					TurnLeft_1();
					pwmcontrol(95);	  
				}
				count++;
				LED3=1;			   //---------D5灭
//				count=3;
             	   for(i=30;i>0;i--)
    				for(j=30;j>0;j--)
				{
					Forward();
					pwmcontrol(95);	  
				}
				Decide();
			}		 
			else  Turning90();	   //当不为超车线且不为第一根线时正常转弯
		} 
		
	}		
}





/*******************************************************************************
* 函 数 名       : Int0()
* 函数功能		 : 外部中断1的中断函数
* 输    入       : 无
* 输    出       : 无
*******************************************************************************/
/*void Int0()	interrupt 0		//外部中断0的中断函数
{
	
} */




/*******************************************************************************
* 函 数 名       : Time0
* 函数功能		 : 定时器0的中断函数
* 输    入       : 无
* 输    出       : 无
*******************************************************************************/
void zd0() interrupt 1    //T0中断用来计数器溢出,超过测距范围       
{ 
   flag=1;            //中断溢出标志   
}





 /*******************************************************************************
* 函 数 名       : Time1
* 函数功能		 : 定时器1的中断函数
* 输    入       : 无
* 输    出       : 无
*******************************************************************************/
void Time1(void) interrupt 3    //3 为定时器1的中断号  1 定时器0的中断号 0 外部中断1 2 外部中断2  4 串口中断
{

	if(count!=3)
	{
		TH1 = 0xFF; 
		TL1 = 0xff;        
    	timer1++; 
	}
	else if(count==3)
	{			  
		TH1 = 65036/256; 
		TL1 = 65036%256; 
		timer1++;
 		if(timer1>=800)     
 	 	{  
  	   	 	D_timer=0;        
    		trig=1;    
    		_nop_();
  		    _nop_();
   		    _nop_();
   		    _nop_();
  		    _nop_();
  		    _nop_();
  		    _nop_();
  	 	    _nop_();
	    	_nop_();          
	    	_nop_();
	   	    _nop_();
	   	    _nop_();
	   	    _nop_();
	   	    _nop_();
	   	    _nop_();
			_nop_();
	   	    _nop_();
	   	    _nop_();      
	  		trig=0;      
		 }
	 }     
}
